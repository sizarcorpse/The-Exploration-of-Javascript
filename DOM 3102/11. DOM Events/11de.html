<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>DOM Events</title>
  </head>
  <!-- 🍤 inline attribute event handler patter  -->
  <body onclick="console.log('fire/trigger attribute event handler')">
    <!-- Event Handlers Types
    1. Inline attribute event handlers
    2. Property event handlers  => you can’t add more than one property event handler to a DOM node when assigning events as property values.
    3. Handler method => addEventListener()

    -->
    <div>Click Me</div>

    <!-- 🍣 DOM Event Types 
    
    User interface events:
    1. load => Event, UIEvent => Fires when an asset (HTML page,image, CSS, frameset, <object>, or JavaScript file) is loaded.
    2. unload => UIEvent => Fires when a user agent removes the resource (document, element, defaultView) or any depending resources (images, CSS file, etc.)
    3. abort => UIEvent => Fires when a resource (object/image) is stopped from loading before it is completely loaded
    4. error => UIEvent => Fires when a resource failed to load, or has been loaded but cannot be interpreted according to its semantics, such as an invalid image, a scriptexecution error, or non-well-formed XML
    5. resize => UIEvent => Fires when a document view has been resized; this event type is dispatched after all effects for that occurrence of resizing of that particular event target have been executed by the user agent
    6. scroll => UIEvent => Fires when a document view or an element has been scrolled
    7. context  => MouseEvent => Fires when the user right-clicks the mouse button over an element 

    Form events:
    1. blur => FocusEvent => Fires when an element loses focus either via the mouse or via tabbing
    2. focus => FocusEvent => Fires when an element gains focus either via the mouse or via tabbing
    3. FocusIn => FocusEvent => Fires when an event target is about to receive focus but before the focus is shifted; this event occurs right before the focus event
    4. FocusOut => FocusEvent => Fires when an event target is about to lose focus but before the focus is shifted; this event occurs right before the blur event

    Form events:
    1. change => Specific to HTML forms => Fires when a control loses the input focus and its value has been modified since gaining focus 
    2. reset => Specific to HTML forms => Fires when a form is reset
    3. Submit => Specific to HTML forms => Fires when a form is submitted
    4. select => Specific to HTML forms =>  Fires when a user selects some text in a text field, including input and textarea

    Mouse events:
    1. click => MouseEvent => Fires when a mouse pointer is clicked (or the user presses the Enter key) over an element. 
                            A click is defined as a mousedown and mouseup over the same screen location. The sequence of these events is mousedown>mouseup>click. 
                            Depending on the environment configuration, the click event may be dispatched if one or more of the event types mouseover, mouse move, 
                            and mouseout occur between the press and release of the pointing device button. The click event may also be followed by the dblclick event.
    2. dblclick => MouseEvent => Fires when a mouse pointer is clicked twice over an element. The definition of a double-click depends on the environment configuration, 
                            except that the event target must be the same between mouse down, mouseup, and dblclick. This event type must be dispatched after the event 
                            type click if a click and double-click occur simultaneously, and after the event type mouseup otherwise.
    3. mousedown => MouseEvent => Fires when a mouse pointer is pressed over an element
    4. mouseup => MouseEvent => Fires when a mouse pointer is pressed over an element
    5. mouseenter => MouseEvent => Fires when a mouse pointer is moved onto the boundaries of an element or one of its descendent elements. This event type is similar to mouse over, 
                            but differs in that it does not bubble and it must not be dispatched when the pointer device moves from an element onto the boundaries of one of its descendent elements.
    6. mouseleave => MouseEvent => Fires when a mouse pointer is moved off the boundaries of an element and all its descendent elements. This event type is similar to mouse out, 
                            but differs in that it does not bubble and it must not be dispatched until the pointing device has left the boundaries of the element and the boundaries of all its children.
    7. mousemove => MouseEvent => Fires when a mouse pointer is moved while it is over an element. The frequency rate of events while the pointing device is moved 
                            is implementation-, device-, and platform-specific, but multiple consecutive mousemove events should be fired for sustained pointer-device movement, 
                            rather than a single event for each instance of mouse movement. Implementations are encouraged to determine the optimal frequency rate to balance 
                            responsiveness with performance.
    8. mouseout => MouseEvent => Fires when a mouse pointer is moved off the boundaries of an element. This event type is similar to mouseleave, but differs in that it does bubble 
                            and it must be dispatched when the pointer device moves from an element onto the boundaries of one of its descendent elements.
    9. mouseover => MouseEvent => Fires when a mouse pointer is moved over an element.

    Keyboard events:
    1. keydown => KeyboardEvent => Fires when a key is initially pressed. This is sent after any key mapping is performed, but before any input method editors receive the keypress. 
                                  This is sent for any key, even if it doesn’t generate a character code.
    2. keypress => KeyboardEvent => Fires when a key is initially pressed, but only if that key normally produces a character value. This is sent after any key mapping is performed, 
                                  but before any input method editors receive the keypress.
    3.keyup => KeyboardEvent => Fires when a key is released. This is sent after any key mapping is performed, and always follows the corresponding keydown and keypress events.
    
    Document-specific events:
    1. DOMContentLoaded => Event => Fires when a web page has been parsed, but before all resources have been fully downloaded

    2. readystatechange => Event => Fires an event when ready State is changed

                                -->

    <!-- Adding Event Listeners to Element Nodes, the
window Object, and the document Object -->
    <div
      class="mouse"
      style="height: 200px; width: 200px; background-color: red"
    >
      mouse over me
    </div>

    <div class="hi" style="height: 200px; width: 200px; background-color: pink">
      click to say hi
    </div>

    <a href="google.com">no go</a>
    <input type="checkbox" />
    <textarea></textarea>

    <div
      class="propagation"
      style="height: 200px; width: 200px; background-color: pink"
    >
      stop propagation
    </div>

    <div
      class="immediate"
      style="height: 200px; width: 200px; background-color: lightgreen"
    >
      stopImmediatePropagation
    </div>
    <div
      class="custom"
      style="height: 200px; width: 200px; background-color: lightcoral"
    >
      Custom Events
    </div>
  </body>
  <script type="text/javascript">
    // var elementDiv = document.querySelector("div");

    // // property event handler pattern
    // elementDiv.onclick = function () {
    //   console.log("fire/trigger property event handler");
    // };

    // //addEventListener method pattern
    // elementDiv.addEventListener(
    //   "click",
    //   function () {
    //     console.log("fire/trigger addEventListener");
    //   },
    //   false
    // );

    let parent = document.querySelector(".parent");
    let child1 = document.querySelector(".parent .child1");
    let child2 = document.querySelector(".parent .child2");

    // parent.addEventListener("mouseover", function (event) {
    //   console.log(event.target.className, " : ➡ mouseenter");
    // });
    // parent.addEventListener("mouseout", function (event) {
    //   console.log(event.target.className, " : ⬅ mouseenter");
    // });

    // child1.addEventListener("mouseenter", function (event) {
    //   console.log(event.target.className, " : ➡ mouseenter");
    // });
    // child1.addEventListener("mouseleave", function (event) {
    //   console.log(event.target.className, " : ⬅ mouseenter");
    // });

    // child2.addEventListener("mouseenter", function (event) {
    //   console.log(event.target.className, " : ➡ mouseenter");
    // });
    // child2.addEventListener("mouseleave", function (event) {
    //   console.log(event.target.className, " : ⬅ mouseenter");

    // });
    // Part -1
    // //1 capture phase
    // window.addEventListener(
    //   "click",
    //   function () {
    //     console.log(1);
    //   },
    //   true
    // );

    // //2 capture phase
    // document.addEventListener(
    //   "click",
    //   function () {
    //     console.log(2);
    //   },
    //   true
    // );

    // //3 capture phase
    // document.documentElement.addEventListener(
    //   "click",
    //   function () {
    //     console.log(3);
    //   },
    //   true
    // );
    // //4 capture phase
    // document.body.addEventListener(
    //   "click",
    //   function () {
    //     console.log(4);
    //   },
    //   true
    // );

    // //5 target phase occurs during capture phase
    // document.querySelector("div").addEventListener(
    //   "click",
    //   function () {
    //     console.log(5);
    //   },
    //   true
    // );
    // // ----- bubbling phase
    // //6 target phase occurs during bubbling phase
    // document.querySelector("div").addEventListener(
    //   "click",
    //   function () {
    //     console.log(6);
    //   },
    //   false
    // );

    // //7 bubbling phase
    // document.body.addEventListener(
    //   "click",
    //   function () {
    //     console.log(7);
    //   },
    //   false
    // );
    // //8 bubbling phase
    // document.documentElement.addEventListener(
    //   "click",
    //   function () {
    //     console.log(8);
    //   },
    //   false
    // );
    // //9 bubbling phase
    // document.addEventListener(
    //   "click",
    //   function () {
    //     console.log(9);
    //   },
    //   false
    // );
    // //10 bubbling phase
    // window.addEventListener(
    //   "click",
    //   function () {
    //     console.log(10);
    //   },
    //   false
    // );

    // part - 2

    // //1 target phase occurs during bubbling phase
    // document.querySelector("div").addEventListener(
    //   "click",
    //   function () {
    //     console.log(1);
    //   },
    //   false
    // );
    // //2 bubbling phase
    // document.body.addEventListener(
    //   "click",
    //   function () {
    //     console.log(2);
    //   },
    //   false
    // );
    // //3 bubbling phase
    // document.documentElement.addEventListener(
    //   "click",
    //   function () {
    //     console.log(3);
    //   },
    //   false
    // );
    // //4 bubbling phase
    // document.addEventListener(
    //   "click",
    //   function () {
    //     console.log(4);
    //   },
    //   false
    // );
    // //5 bubbling phase
    // window.addEventListener(
    //   "click",
    //   function () {
    //     console.log(5);
    //   },
    //   false
    // );

    // Adding Event Listeners to Element Nodes, the window Object, and the document Object

    /* add a mousemove event to the window object, invoking the event during the
        bubbling phase */
    // window.addEventListener(
    //   "mousemove",
    //   function () {
    //     console.log("moving over window");
    //   },
    //   false
    // );
    /* add a mousemove event to the document object, invoking the event during the
        bubbling phase */
    // document.addEventListener(
    //   "mousemove",
    //   function () {
    //     console.log("moving over document");
    //   },
    //   false
    // );
    /* add a mousemove event to a <div> element object, invoking the event during the
        bubbling phase */
    // Adding Event Listeners to Element Nodes, the window Object, and the document Object | 137
    // document.querySelector("div.mouse").addEventListener(
    //   "mousemove",
    //   function (e) {
    //     console.log("moving over div");
    //   },
    //   false
    // );

    // 🧡 Removing Event Listeners

    var sayHi = function () {
      console.log("hi");
    };

    //adding event listener using anonymous function
    document.body.addEventListener(
      "click",
      function () {
        console.log("dude");
      },
      false
    );

    //adding event listener using function reference
    document.querySelector("div.hi").addEventListener("click", sayHi, false);

    /* attempt to remove both event listeners, but only the listener added with a
    function reference is removed */
    document.querySelector("div.hi").removeEventListener("click", sayHi, false);

    // 💝  Getting Event Properties from the Event Object
    document.querySelector("div.hi").addEventListener(
      "click",
      function (event) {
        Object.keys(event)
          .sort()
          .forEach(function (item) {
            console.log(item + " = " + event[item]); //logs event properties and values
          });
      },
      false
    );

    //assumes 'this' is window
    this.addEventListener(
      "load",
      function (event) {
        Object.keys(event)
          .sort()
          .forEach(function (item) {
            console.log(item + " = " + event[item]); //logs event properties and values
          });
      },
      false
    );

    // The Value of this When Using addEventListener()
    document.querySelector("div.hi").addEventListener(
      "click",
      function () {
        // 'this' will be the element or node the event listener is attached to
        console.log("yoo", this); //logs '<div>'
      },
      false
    );

    document.addEventListener(
      "click",
      function (event) {
        console.log(event.currentTarget); //logs '#document'
        //same as...
        console.log(this);
      },
      false
    );

    document.body.addEventListener(
      "click",
      function (event) {
        /* when the <div> is clicked logs '<div>' because the <div> was the target in
    the event flow */
        console.log("hola", event.target);
      },
      false
    );

    // Using preventDefault() to Cancel Default Browser Events

    document.querySelector("a").addEventListener(
      "click",
      function (event) {
        event.preventDefault(); /* stop the default event for <a>, which would be to load
     a url */
      },
      false
    );

    document.querySelector("input").addEventListener(
      "click",
      function (event) {
        event.preventDefault(); /* stop default event for checkbox, which would be to
     toggle checkbox state */
      },
      false
    );

    document.querySelector("textarea").addEventListener(
      "keypress",
      function (event) {
        event.preventDefault(); /* stop default event for textarea, which would be to add
     characters typed */
      },
      false
    );

    // Stop Propagate Event

    document.querySelector("div.propagation").addEventListener(
      "click",
      function () {
        console.log("me too, but nothing from the event flow!");
      },
      false
    );

    document.querySelector("div.propagation").addEventListener(
      "click",
      function (event) {
        console.log(
          "invoked all click events attached, but cancel capture and bubble event phases"
        );
        event.stopPropagation();
      },
      false
    );

    document.querySelector("div.propagation").addEventListener(
      "click",
      function () {
        console.log("me too, but nothing from the event flow!");
      },
      false
    );

    /* when the <div> is clicked, this event is not invoked because one of the events
attached to the <div> stops the capture and bubble flow. */
    document.body.addEventListener(
      "click",
      function () {
        console.log("What, denied from being invoked!");
      },
      false
    );

    // Using stopImmediatePropagation() to Stop the Event Flow As Well As Other Like Events on the Same Target

    //first event attached
    document.querySelector("div.immediate").addEventListener(
      "click",
      function () {
        console.log("I get invoked because I was attached first");
      },
      false
    );

    //second event attached
    document.querySelector("div.immediate").addEventListener(
      "click",
      function (event) {
        console.log(
          "I get invoked, but stop any other click events on this target"
        );
        event.stopImmediatePropagation();
      },
      false
    );

    /* third event attached, but because stopImmediatePropagation() was called above
this event does not get invoked */
    document.querySelector("div").addEventListener(
      "click",
      function () {
        console.log("I get stopped from the previous click event listener");
      },
      false
    );

    /* notice that the event flow is also cancelled as if stopPropagation was
called too */
    document.body.addEventListener(
      "click",
      function () {
        console.log("What, denied from being invoked!");
      },
      false
    );

    // Custom Events

    var divElement = document.querySelector("div.custom");

    //create the custom event
    var cheer =
      document.createEvent("CustomEvent"); /* the 'CustomEvent' parameter
 is required */

    //create an event listener for the custom event
    divElement.addEventListener(
      "goBigBlue",
      function (event) {
        console.log(event.detail.goBigBlueIs);
      },
      false
    );
    /* Use the initCustomEvent method to set up the details of the custom event.
Parameters for initCustomEvent are: (event, bubble?, cancelable?, pass values
to event.detail) */
    cheer.initCustomEvent("goBigBlue", true, false, {
      goBigBlueIs: "its gone!",
    });

    //invoke the custom event using dispatchEvent
    divElement.dispatchEvent(cheer);
  </script>
</html>
